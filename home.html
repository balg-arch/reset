<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>RESET</title>
  <link rel="canonical" href="https://glyphreset.app/"/>

  <meta name="theme-color" content="#ffffff">
  <link rel="icon" href="favicon-32.png" sizes="32x32">
  <link rel="icon" href="favicon-16.png" sizes="16x16">
  <link rel="shortcut icon" href="favicon.ico">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <link rel="manifest" href="site.webmanifest">

  <meta property="og:title" content="RESET">
  <meta property="og:site_name" content="RESET">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://glyphreset.app/">
  <meta property="og:image" content="https://glyphreset.app/android-chrome-512.png">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="RESET">
  <meta name="twitter:image" content="https://glyphreset.app/android-chrome-512.png">

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@graph": [
      {
        "@type": "WebSite",
        "@id": "https://glyphreset.app/#website",
        "name": "RESET",
        "url": "https://glyphreset.app/",
        "inLanguage": "en"
      },
      {
        "@type": "WebPage",
        "@id": "https://glyphreset.app/rebalancing-session⌀webpage",
        "url": "https://glyphreset.app/",
        "name": "RESET",
        "isPartOf": { "@id": "https://glyphreset.app/#website" },
        "inLanguage": "en"
      }
    ]
  }
  </script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Share+Tech+Mono&display=swap');
    :root{--bg:#ffffff;--surface:#ffffff;--surface-2:#f5f5f7;--fg:#0f0f10;--muted:#3f3f46;--border:rgba(0,0,0,.10);--border-strong:rgba(0,0,0,.16);--shadow:0 10px 30px rgba(0,0,0,.08);--radius:16px;--accent:#D71921;--accent-2:#ff3b30;--mono:"Share Tech Mono",ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;--sans:"Space Grotesk",ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Inter,Arial;--focus:0 0 0 4px rgba(215,25,33,.22)}
    html,body{margin:0;padding:0;height:100%;background:var(--bg);color:var(--fg)}
    body{font-family:var(--sans);overflow-wrap:anywhere;word-break:break-word}
    body::before{content:"";position:fixed;inset:0;pointer-events:none;background:radial-gradient(circle at 1px 1px,rgba(0,0,0,.085) 1px,transparent 1.25px) 0 0/14px 14px,radial-gradient(circle at 1px 1px,rgba(0,0,0,.04) 1px,transparent 1.25px) 7px 7px/14px 14px,radial-gradient(circle at 1px 1px,rgba(215,25,33,.06) 1px,transparent 1.3px) 0 0/56px 56px,linear-gradient(90deg,rgba(0,0,0,.035) 1px,transparent 1px) 0 0/112px 112px,linear-gradient(180deg,rgba(0,0,0,.035) 1px,transparent 1px) 0 0/112px 112px,linear-gradient(to bottom,rgba(0,0,0,.03),transparent 30%,transparent 70%,rgba(0,0,0,.02));opacity:.55;mix-blend-mode:multiply}
    .wrap{position:relative;z-index:1;min-height:100vh;min-height:100dvh;display:grid;place-items:center;padding:7.5vh 20px}
    .panel{width:100%;max-width:1060px;text-align:center}
    .title{font-family:var(--mono);text-transform:uppercase;font-size:clamp(2.2rem,5.3vw,5.2rem);font-weight:700;letter-spacing:.16em;margin:0 0 12px;line-height:.95;text-shadow:0 0 0 rgba(255,255,255,0),0 0 18px rgba(255,255,255,.06),0 0 28px rgba(215,25,33,.08)}
    .divider{width:72px;height:2px;background:linear-gradient(90deg,transparent,var(--accent),transparent);margin:14px auto 20px;border-radius:2px;opacity:.95}
    .subtitle{margin:0 auto;max-width:780px;color:var(--muted);font-size:.98rem;line-height:1.6;letter-spacing:.02em}
    .links{display:flex;justify-content:center;gap:12px;flex-wrap:wrap;margin-top:18px}
    .grid{margin-top:22px;display:grid;grid-template-columns:1fr 1fr;gap:14px;text-align:left;align-items:start}
    @media (max-width:980px){.grid{grid-template-columns:1fr}}
    .card{border:1px solid var(--border);border-radius:var(--radius);background:var(--surface);box-shadow:var(--shadow);position:relative;padding:16px;backdrop-filter:saturate(1.1) blur(8px)}
    .card::before{content:"";position:absolute;inset:10px;border-radius:calc(var(--radius) - 8px);pointer-events:none;opacity:.22;background:repeating-linear-gradient(90deg,rgba(255,255,255,.18) 0 1px,transparent 1px 10px);mix-blend-mode:overlay}
    .card h2{margin:0 0 12px;font-size:12px;text-transform:uppercase;letter-spacing:.18em;color:rgba(15,15,16,.92);font-family:var(--mono)}
    .sep{height:1px;background:linear-gradient(90deg,transparent,rgba(255,255,255,.14),transparent);margin:14px 0}
    .row{display:flex;gap:10px;align-items:center;margin:10px 0;flex-wrap:wrap}
    .row label{flex:1 1 180px;font-size:12px;letter-spacing:.04em;color:rgba(15,15,16,.80)}
    input[type="number"],select{background:rgba(245,245,247,.92);color:var(--fg);border:1px solid var(--border);border-radius:14px;padding:10px 12px;font-weight:600;letter-spacing:.01em;transition:border-color .15s ease,box-shadow .15s ease,background .15s ease;outline:none}
    input[type="number"]{width:140px}
    select{min-width:220px}
    input[type="number"]:focus,select:focus{border-color:rgba(215,25,33,.55);box-shadow:var(--focus);background:#fff}
    input[type="range"]{width:min(280px,100%);accent-color:var(--accent)}
    .mono{font-family:var(--mono)}
    .small{font-size:12px;color:var(--muted);line-height:1.45;margin:10px 0 0}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid var(--border);background:rgba(0,0,0,.02);font-size:12px;color:rgba(15,15,16,.95);backdrop-filter:saturate(1.1) blur(8px)}
    .pill::before{content:"";width:8px;height:8px;border-radius:50%;background:var(--accent);box-shadow:0 0 0 3px rgba(215,25,33,.16)}
    .row button,.btn{background:rgba(0,0,0,.02);color:var(--fg);border:1px solid var(--border);border-radius:999px;padding:10px 14px;font-weight:700;letter-spacing:.02em;cursor:pointer;transition:transform .12s ease,border-color .15s ease,background .15s ease,box-shadow .15s ease;backdrop-filter:saturate(1.1) blur(8px)}
    .btn:hover{transform:translateY(-1px);border-color:var(--border-strong);background:rgba(0,0,0,.035)}
    .btn:focus-visible{outline:none;box-shadow:var(--focus)}
    .btn.primary{background:linear-gradient(180deg,rgba(215,25,33,.25),rgba(215,25,33,.12));border-color:rgba(215,25,33,.55)}
    .btn.primary:hover{background:linear-gradient(180deg,rgba(215,25,33,.32),rgba(215,25,33,.16));border-color:rgba(215,25,33,.70)}
    .btn.danger{background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(0,0,0,.18));border-color:rgba(255,255,255,.16)}
    canvas{width:100%;height:260px;background:rgba(245,245,247,.92);border:1px solid var(--border);border-radius:var(--radius);display:block}
    .kvs{display:grid;grid-template-columns:1fr;gap:8px}
    .kv{display:flex;justify-content:space-between;gap:12px;padding:10px 12px;border:1px solid var(--border);border-radius:14px;background:rgba(245,245,247,.92);backdrop-filter:saturate(1.1) blur(8px)}
    .kv b{font-size:12px;letter-spacing:.05em;color:rgba(15,15,16,.78);font-family:var(--mono)}
    .kv span{font-size:12px;color:rgba(15,15,16,.92)}
    .sessionText{border:1px solid var(--border);border-radius:14px;background:rgba(245,245,247,.92);padding:12px;min-height:92px;line-height:1.45;font-size:13px;color:rgba(15,15,16,.95);backdrop-filter:saturate(1.1) blur(8px)}
    .sessionText b{color:var(--fg)}
    .sessionText .mono{color:rgba(15,15,16,.88)}
    .twoCol{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    @media (max-width:540px){.twoCol{grid-template-columns:1fr}}
    .glyph-strip{position:sticky;top:0;z-index:50;display:flex;align-items:center;justify-content:space-between;gap:14px;padding:10px 12px;margin:0 0 14px 0;border:1px solid rgba(0,0,0,.10);border-radius:18px;background:rgba(255,255,255,.86);backdrop-filter:saturate(1.1) blur(8px);box-shadow:0 10px 30px rgba(0,0,0,.10)}
    .glyph-strip::before{content:"";position:absolute;inset:0;border-radius:18px;pointer-events:none;opacity:.55;background:radial-gradient(circle at 20% 0%,rgba(255,46,46,.20),transparent 38%),radial-gradient(circle at 85% 120%,rgba(255,46,46,.10),transparent 40%);mix-blend-mode:screen}
    .glyph-strip>*{position:relative}
    .gs-left{display:flex;align-items:center;gap:10px;min-width:170px}
    .gs-mark{width:26px;height:26px;display:grid;place-items:center;border-radius:10px;border:1px solid rgba(0,0,0,.10);background:rgba(0,0,0,.02);box-shadow:inset 0 0 0 1px rgba(255,255,255,.02)}
    .gs-title{letter-spacing:.26em;font-size:12px;opacity:.92}
    .gs-meters{flex:1 1 auto;display:flex;align-items:center;justify-content:center;gap:10px;min-width:0}
    .gs-meter{display:flex;align-items:center;gap:8px;padding:7px 10px;border-radius:999px;border:1px solid rgba(0,0,0,.10);background:rgba(0,0,0,.02)}
    .gs-tag{font-size:11px;letter-spacing:.18em;opacity:.78}
    .gs-bar{--v:.5;position:relative;width:120px;height:10px;border-radius:999px;overflow:hidden;background:rgba(0,0,0,.06);box-shadow:inset 0 0 0 1px rgba(255,255,255,.02)}
    .gs-bar::after{content:"";position:absolute;inset:0;width:calc(var(--v) * 100%);background:radial-gradient(circle at 0 50%,rgba(255,46,46,.95),rgba(255,46,46,.45) 55%,rgba(255,46,46,.18) 70%,transparent 100%),linear-gradient(90deg,rgba(255,46,46,.75),rgba(255,46,46,.15));filter:saturate(1.15)}
    .gs-bar::before{content:"";position:absolute;inset:0;opacity:.28;background:repeating-linear-gradient(90deg,rgba(255,255,255,.18),rgba(255,255,255,.18) 1px,transparent 1px,transparent 9px);mix-blend-mode:overlay}
    .gs-right{display:flex;align-items:center;gap:10px;min-width:160px;justify-content:flex-end}
    .gs-phase,.gs-clock{padding:7px 10px;border-radius:999px;border:1px solid rgba(0,0,0,.10);background:rgba(0,0,0,.02);letter-spacing:.14em;text-align:center}
    .gs-phase{min-width:64px}
    .gs-clock{min-width:72px;opacity:.9}
    .gs-run{width:42px;height:18px;display:inline-block;border-radius:999px;border:1px solid rgba(0,0,0,.10);background:rgba(0,0,0,.02);position:relative;overflow:hidden}
    .gs-run::before{content:"";position:absolute;inset:0;background:radial-gradient(circle at 12px 50%,rgba(255,255,255,.65),transparent 45%),radial-gradient(circle at 21px 50%,rgba(255,255,255,.65),transparent 45%),radial-gradient(circle at 30px 50%,rgba(255,255,255,.65),transparent 45%);opacity:.35}
    body.is-running .gs-run::after{content:"";position:absolute;inset:-40% -60%;background:linear-gradient(120deg,transparent 40%,rgba(255,46,46,.22),transparent 60%);animation:gsSweep 1.35s linear infinite}
    @keyframes gsSweep{0%{transform:translateX(-30%);opacity:0}20%{opacity:.85}60%{opacity:.55}100%{transform:translateX(30%);opacity:0}}
    @media (max-width:720px){.glyph-strip{flex-wrap:wrap;gap:10px}.gs-left{min-width:auto}.gs-meters{justify-content:space-between}.gs-bar{width:86px}.gs-right{min-width:auto}}
    @media (max-width:520px){.wrap{padding-top:8vh}select{min-width:100%}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="glyph-strip" role="status" aria-label="Glyph strip">
      <div class="gs-left"><span class="gs-mark" aria-hidden="true">⦿</span><span class="gs-title mono">RESET</span></div>
      <div class="gs-meters" aria-label="Live metrics">
        <div class="gs-meter" title="Coherence"><span class="gs-tag mono">COH</span><span id="gsCoh" class="gs-bar" style="--v:0.50"></span></div>
        <div class="gs-meter" title="Tension"><span class="gs-tag mono">TEN</span><span id="gsTen" class="gs-bar" style="--v:0.20"></span></div>
        <div class="gs-meter" title="Breath amplitude"><span class="gs-tag mono">BR</span><span id="gsBr" class="gs-bar" style="--v:0.00"></span></div>
      </div>
      <div class="gs-right"><span id="gsPhase" class="gs-phase mono">⌀</span><span id="gsClock" class="gs-clock mono">00:00</span><span id="gsRun" class="gs-run" aria-hidden="true"></span></div>
    </div>

    <section class="panel" aria-label="Glyph Reset Drill">
      <h1 class="title">RESET</h1>
      <div class="divider" aria-hidden="true"></div>
      <p class="subtitle">Use <b>Start</b> to begin.</p>
      <nav class="links" aria-label="Primary links"></nav>

      <div class="grid" role="group" aria-label="Session interface">
        <section class="card" aria-label="Controls">
          <h2>Transport</h2>
          <div class="row">
            <button id="btnStart" class="btn primary" type="button">Start</button>
            <button id="btnStop" class="btn danger" type="button">Stop</button>
            <button id="btnFullscreen" class="btn" type="button">Fullscreen</button>
            <span class="pill mono" id="status" data-kind="idle">⌀ (silence)</span>
          </div>

          <div class="sep"></div>

          <h2>Session</h2>
          <div class="row">
            <label for="sessionGoal">Reset type</label>
            <select id="sessionGoal">
              <option value="rebalance" selected>Rebalance (▢ ⟶ ⦿)</option>
              <option value="focus">Focus (△ ⟶ ■)</option>
              <option value="calm">Calm (⌀ ⟶ ⟲)</option>
            </select>
          </div>

          <div class="row">
            <label for="sessionMin">Meditation length (minutes)</label>
            <input id="sessionMin" type="number" min="2" max="90" step="1" value="10"/>
          </div>

          <div class="row">
            <label for="sessionMode">Session mode</label>
            <select id="sessionMode">
              <option value="guided" selected>Guided (prompts + timing)</option>
              <option value="free">Free (breath + aura only)</option>
            </select>
          </div>

          <div class="sep"></div>

          <h2>Breath Engine</h2>
          <div class="twoCol">
            <div class="row" style="margin:0;">
              <label for="breathPreset">Preset</label>
              <select id="breathPreset">
                <option value="box">Box 4–4–4–4</option>
                <option value="coherent" selected>Coherent 5–0–5–0</option>
                <option value="relax">Relax 4–0–6–0</option>
                <option value="focus">Focus 6–2–6–2</option>
                <option value="custom">Custom</option>
              </select>
            </div>
            <div class="row" style="margin:0;"><label for="breathRateHint">Breath hint</label><span class="pill mono" id="breathRateHint">⟶ ~6 bpm</span></div>
          </div>

          <div class="row"><label for="inhaleSec">Inhale (sec)</label><input id="inhaleSec" type="number" min="1" max="20" step="1" value="5"/></div>
          <div class="row"><label for="hold1Sec">Hold (sec)</label><input id="hold1Sec" type="number" min="0" max="20" step="1" value="0"/></div>
          <div class="row"><label for="exhaleSec">Exhale (sec)</label><input id="exhaleSec" type="number" min="1" max="30" step="1" value="5"/></div>
          <div class="row"><label for="hold2Sec">Hold (sec)</label><input id="hold2Sec" type="number" min="0" max="20" step="1" value="0"/></div>

          <div class="row"><label for="breathStrength">Breath⟶Audio coupling (⟲)</label><input id="breathStrength" type="range" min="0" max="1" step="0.001" value="0.55"/><span class="mono" id="breathStrengthV"></span></div>

          <div class="sep"></div>

          <h2>Sound Field</h2>
          <div class="row"><label for="intensity">Intensity (⦿)</label><input id="intensity" type="range" min="0" max="1" step="0.001" value="0.50"/><span class="mono" id="intensityV"></span></div>
          <div class="row"><label for="brightness">Brightness (△)</label><input id="brightness" type="range" min="0" max="1" step="0.001" value="0.33"/><span class="mono" id="brightnessV"></span></div>
          <div class="row"><label for="density">Density (▢)</label><input id="density" type="range" min="0" max="1" step="0.001" value="0.38"/><span class="mono" id="densityV"></span></div>
          <div class="row"><label for="regen">Regeneration (⟲)</label><input id="regen" type="range" min="0" max="1" step="0.001" value="0.62"/><span class="mono" id="regenV"></span></div>
          <div class="row"><label for="silenceBias">Silence bias (⌀)</label><input id="silenceBias" type="range" min="0" max="1" step="0.001" value="0.20"/><span class="mono" id="silenceV"></span></div>

          <div class="sep"></div>

          <h2>Actions</h2>
          <div class="row" style="justify-content:space-between;">
            <button id="btnNewConfig" class="btn" type="button">Generate new configuration ⟦…⟧</button>
            <button id="btnFreeze" class="btn" type="button">Freeze (⫶)</button>
          </div>
          <p class="small">Audio starts only after your click (browser policy).</p>
        </section>

        <section class="card" aria-label="Monitor">
          <h2>Breath + Aura Monitor</h2>
          <canvas id="field" width="1000" height="360" aria-label="Aura field monitor"></canvas>
          <div class="sep"></div>
          <div class="kvs" aria-label="Telemetry">
            <div class="kv"><b>Breath phase ⟶</b><span class="mono" id="phase"></span></div>
            <div class="kv"><b>Aura coherence (▢)</b><span class="mono" id="aura"></span></div>
            <div class="kv"><b>Configuration ⟦…⟧</b><span class="mono" id="cfg"></span></div>
            <div class="kv"><b>Session vector ⟶</b><span class="mono" id="intent"></span></div>
            <div class="kv"><b>Memory trace (⟲)</b><span class="mono" id="mem"></span></div>
          </div>
          <div class="sep"></div>
          <h2>Guidance</h2>
          <div class="sessionText" id="prompt" aria-label="Session prompt">⌀ (silence) — press Start.</div>
          <p class="small">This is a coordination practice. If discomfort arises, return to ⌀ (pause), reduce intensity, or stop.</p>
        </section>
      </div>

      <script>
        (() => {
          const clamp = (x, a = 0, b = 1) => Math.min(b, Math.max(a, x));
          const lerp = (a, b, t) => a + (b - a) * t;

          function mulberry32(seed) {
            let t = seed >>> 0;
            return function () {
              t += 0x6D2B79F5;
              let r = Math.imul(t ^ (t >>> 15), 1 | t);
              r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
              return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
            };
          }

          const el = (id) => document.getElementById(id);

          const ui = {
            start: el("btnStart"),
            stop: el("btnStop"),
            fullscreen: el("btnFullscreen"),
            status: el("status"),
            gsCoh: el("gsCoh"),
            gsTen: el("gsTen"),
            gsBr: el("gsBr"),
            gsPhase: el("gsPhase"),
            gsClock: el("gsClock"),
            sessionGoal: el("sessionGoal"),
            sessionMin: el("sessionMin"),
            sessionMode: el("sessionMode"),
            breathPreset: el("breathPreset"),
            inhaleSec: el("inhaleSec"),
            hold1Sec: el("hold1Sec"),
            exhaleSec: el("exhaleSec"),
            hold2Sec: el("hold2Sec"),
            breathStrength: el("breathStrength"),
            breathStrengthV: el("breathStrengthV"),
            breathRateHint: el("breathRateHint"),
            intensity: el("intensity"),
            brightness: el("brightness"),
            density: el("density"),
            regen: el("regen"),
            silenceBias: el("silenceBias"),
            intensityV: el("intensityV"),
            brightnessV: el("brightnessV"),
            densityV: el("densityV"),
            regenV: el("regenV"),
            silenceV: el("silenceV"),
            newConfig: el("btnNewConfig"),
            freeze: el("btnFreeze"),
            phase: el("phase"),
            aura: el("aura"),
            cfg: el("cfg"),
            intent: el("intent"),
            mem: el("mem"),
            prompt: el("prompt"),
            canvas: el("field")
          };

          function fmt(x, n = 3) { return Number(x).toFixed(n); }
          function fmtMMSS(sec) { sec = Math.max(0, sec | 0); const m = Math.floor(sec / 60); const s = sec % 60; return String(m).padStart(2, "0") + ":" + String(s).padStart(2, "0"); }
          function midiToHz(m) { return 440 * Math.pow(2, (m - 69) / 12); }

          function syncValues() {
            ui.intensityV.textContent = fmt(ui.intensity.value);
            ui.brightnessV.textContent = fmt(ui.brightness.value);
            ui.densityV.textContent = fmt(ui.density.value);
            ui.regenV.textContent = fmt(ui.regen.value);
            ui.silenceV.textContent = fmt(ui.silenceBias.value);
            ui.breathStrengthV.textContent = fmt(ui.breathStrength.value);
            const cycle = Math.max(1,
              parseInt(ui.inhaleSec.value || "0", 10) +
              parseInt(ui.hold1Sec.value || "0", 10) +
              parseInt(ui.exhaleSec.value || "0", 10) +
              parseInt(ui.hold2Sec.value || "0", 10)
            );
            ui.breathRateHint.textContent = `⟶ ~${(60 / cycle).toFixed(1)} bpm`;
          }

          ["intensity", "brightness", "density", "regen", "silenceBias", "breathStrength", "inhaleSec", "hold1Sec", "exhaleSec", "hold2Sec"].forEach(k => ui[k].addEventListener("input", syncValues));
          syncValues();

          const state = {
            seed: (Date.now() & 0xffffffff) >>> 0,
            frozen: false,
            intensity: parseFloat(ui.intensity.value),
            brightness: parseFloat(ui.brightness.value),
            density: parseFloat(ui.density.value),
            regen: parseFloat(ui.regen.value),
            silenceBias: parseFloat(ui.silenceBias.value),
            breath: { phase: "silence", tPhaseStart: 0, phaseDur: 1, amp: 0, smoothAmp: 0 },
            aura: { coherenceEMA: 0.5, drift: 0 },
            memory: { energyEMA: 0, tensionEMA: 0 },
            session: { active: false, startAt: 0, endAt: 0, stepIdx: 0, steps: [] },
            meditationEndAt: 0,
            lastSilenceAt: 0,
            config: null
          };

          const INK = (getComputedStyle(document.documentElement).getPropertyValue("--fg") || "#0f0f10").trim();

          function setStatus(txt, kind = "field") { ui.status.textContent = txt; ui.status.dataset.kind = kind; }

          function updateGlyphStrip(audioRunning, remainingSec) {
            const coh = clamp(state.aura.coherenceEMA, 0, 1);
            const ten = clamp(state.memory.tensionEMA, 0, 1);
            const br = clamp(state.breath.smoothAmp, 0, 1);
            ui.gsCoh.style.setProperty("--v", coh.toFixed(3));
            ui.gsTen.style.setProperty("--v", ten.toFixed(3));
            ui.gsBr.style.setProperty("--v", br.toFixed(3));
            const ph = state.breath.phase || "⌀";
            const glyph = ph === "inhale" ? "↑ IN" : ph === "exhale" ? "↓ OUT" : ph === "hold1" ? "— H1" : ph === "hold2" ? "— H2" : "⌀ OFF";
            ui.gsPhase.textContent = glyph;
            ui.gsClock.textContent = audioRunning ? fmtMMSS(remainingSec) : "00:00";
          }

          function applyPreset(p) {
            const set = (a, b, c, d) => { ui.inhaleSec.value = a; ui.hold1Sec.value = b; ui.exhaleSec.value = c; ui.hold2Sec.value = d; syncValues(); };
            if (p === "box") set(4, 4, 4, 4);
            if (p === "coherent") set(5, 0, 5, 0);
            if (p === "relax") set(4, 0, 6, 0);
            if (p === "focus") set(6, 2, 6, 2);
          }

          ui.breathPreset.addEventListener("change", () => { const p = ui.breathPreset.value; if (p !== "custom") applyPreset(p); });

          function getBreathDurations() {
            return {
              inhale: Math.max(1, parseInt(ui.inhaleSec.value || "5", 10)),
              hold1: Math.max(0, parseInt(ui.hold1Sec.value || "0", 10)),
              exhale: Math.max(1, parseInt(ui.exhaleSec.value || "5", 10)),
              hold2: Math.max(0, parseInt(ui.hold2Sec.value || "0", 10))
            };
          }

          function setBreathPhase(name, dur, now) {
            state.breath.phase = name;
            state.breath.tPhaseStart = now;
            state.breath.phaseDur = Math.max(0.001, dur);
            const label = (name === "hold1" || name === "hold2") ? "hold" : name;
            ui.phase.textContent = `${label} ⟶ ${dur.toFixed(0)}s`;
          }

          function stepBreath(now) {
            const d = getBreathDurations();
            const elapsed = now - state.breath.tPhaseStart;
            if (state.breath.phase === "silence") { setBreathPhase("inhale", d.inhale, now); }
            else if (elapsed >= state.breath.phaseDur) {
              if (state.breath.phase === "inhale") setBreathPhase(d.hold1 > 0 ? "hold1" : "exhale", d.hold1 > 0 ? d.hold1 : d.exhale, now);
              else if (state.breath.phase === "hold1") setBreathPhase("exhale", d.exhale, now);
              else if (state.breath.phase === "exhale") setBreathPhase(d.hold2 > 0 ? "hold2" : "inhale", d.hold2 > 0 ? d.hold2 : d.inhale, now);
              else if (state.breath.phase === "hold2") setBreathPhase("inhale", d.inhale, now);
            }
            const p = clamp((now - state.breath.tPhaseStart) / state.breath.phaseDur);
            let amp = state.breath.amp;
            if (state.breath.phase === "inhale") amp = 0.5 - 0.5 * Math.cos(Math.PI * p);
            if (state.breath.phase === "exhale") amp = 0.5 + 0.5 * Math.cos(Math.PI * p);
            if (state.breath.phase === "hold1") amp = lerp(state.breath.amp, 1.0, 0.12);
            if (state.breath.phase === "hold2") amp = lerp(state.breath.amp, 0.0, 0.12);
            state.breath.amp = clamp(amp);
            state.breath.smoothAmp = lerp(state.breath.smoothAmp, state.breath.amp, 0.08);
          }

          function createReverbImpulse(ctx, seconds = 3.2, decay = 2.4) {
            const rate = ctx.sampleRate;
            const len = Math.max(1, Math.floor(seconds * rate));
            const impulse = ctx.createBuffer(2, len, rate);
            for (let ch = 0; ch < 2; ch++) {
              const data = impulse.getChannelData(ch);
              for (let i = 0; i < len; i++) {
                const t = i / len;
                const env = Math.pow(1 - t, decay);
                data[i] = (Math.random() * 2 - 1) * env;
              }
            }
            return impulse;
          }

          function makeNoiseBuffer(ctx, seconds = 0.5) {
            const len = Math.max(1, Math.floor(ctx.sampleRate * seconds));
            const buf = ctx.createBuffer(1, len, ctx.sampleRate);
            const data = buf.getChannelData(0);
            for (let i = 0; i < len; i++) data[i] = (Math.random() * 2 - 1);
            return buf;
          }

          class AudioEngine {
            constructor() {
              this.ctx = null;
              this.master = null;
              this.analyser = null;
              this.running = false;
              this.scene = null;
              this.bus = null;
              this.noise = null;
              this.scheduler = null;
              this.nextEventAt = 0;
              this.rand = mulberry32(state.seed);
            }

            ensure() {
              if (this.ctx) return;
              this.ctx = new (window.AudioContext || window.webkitAudioContext)();
              this.master = this.ctx.createGain();
              this.master.gain.value = 0.0;

              const input = this.ctx.createGain();
              const filter = this.ctx.createBiquadFilter();
              filter.type = "lowpass";
              filter.frequency.value = 1600;
              filter.Q.value = 0.22;

              const convolver = this.ctx.createConvolver();
              convolver.buffer = createReverbImpulse(this.ctx, 3.6, 2.6);

              const wet = this.ctx.createGain();
              const dry = this.ctx.createGain();
              wet.gain.value = 0.26;
              dry.gain.value = 0.90;

              const limiter = this.ctx.createDynamicsCompressor();
              limiter.threshold.value = -18;
              limiter.knee.value = 18;
              limiter.ratio.value = 10;
              limiter.attack.value = 0.003;
              limiter.release.value = 0.16;

              this.analyser = this.ctx.createAnalyser();
              this.analyser.fftSize = 1024;

              input.connect(filter);
              filter.connect(dry);
              filter.connect(convolver);
              convolver.connect(wet);
              dry.connect(this.analyser);
              wet.connect(this.analyser);
              this.analyser.connect(limiter);
              limiter.connect(this.master);
              this.master.connect(this.ctx.destination);

              this.bus = { input, filter, wet, dry };
              this.noise = makeNoiseBuffer(this.ctx, 1.0);
            }

            async start() {
              this.ensure();
              await this.ctx.resume();
              this.running = true;
              const t = this.ctx.currentTime;
              this.master.gain.cancelScheduledValues(t);
              this.master.gain.setValueAtTime(this.master.gain.value, t);
              this.master.gain.linearRampToValueAtTime(0.28, t + 1.6);
              this.setGoal(ui.sessionGoal.value, true);
              this.nextEventAt = this.ctx.currentTime + 0.05;
              if (!this.scheduler) this.scheduler = setInterval(() => this.schedule(), 80);
            }

            stop(reason = "stop") {
              if (!this.running) return;
              this.running = false;
              const t = this.ctx.currentTime;
              this.master.gain.cancelScheduledValues(t);
              this.master.gain.setValueAtTime(this.master.gain.value, t);
              this.master.gain.linearRampToValueAtTime(0.0, t + 1.1);
              if (this.scheduler) { clearInterval(this.scheduler); this.scheduler = null; }
              if (this.scene?.dispose) this.scene.dispose();
              this.scene = null;
            }

            setGoal(goal, hard = false) {
              state.seed = (state.seed + 0x9e3779b9) >>> 0;
              this.rand = mulberry32(state.seed);
              state.config = this.makeConfig(goal, this.rand);
              ui.cfg.textContent = state.config.label;
              if (this.scene?.dispose) this.scene.dispose();
              this.scene = this.buildScene(goal, state.config, hard);
              this.applyMix(goal, hard);
            }

            applyMix(goal, hard) {
              const cfg = state.config;
              const t = this.ctx.currentTime;
              const wet = cfg.wet;
              const dry = clamp(0.98 - wet * 0.55, 0.55, 1.0);
              const lp = cfg.lp;
              this.bus.wet.gain.setTargetAtTime(wet, t, hard ? 0.08 : 0.18);
              this.bus.dry.gain.setTargetAtTime(dry, t, hard ? 0.08 : 0.18);
              this.bus.filter.frequency.setTargetAtTime(lp, t, hard ? 0.08 : 0.18);
            }

            makeConfig(goal, r) {
              const pick = (arr) => arr[Math.floor(r() * arr.length)];
              const between = (a, b) => lerp(a, b, r());
              const roots = goal === "calm" ? [36, 48] : goal === "focus" ? [44, 58] : [40, 54];
              const root = Math.round(between(roots[0], roots[1]));
              const scales = {
                rebalance: [[0, 2, 3, 5, 7, 10], [0, 2, 5, 7, 10], [0, 3, 5, 7, 10]],
                focus: [[0, 2, 4, 7, 9], [0, 2, 4, 5, 7, 9, 11]],
                calm: [[0, 3, 5, 7, 10], [0, 2, 3, 5, 7, 8, 10]]
              };
              const scale = pick(scales[goal] || scales.rebalance);
              const chordSize = goal === "focus" ? 3 : goal === "calm" ? 4 : 5;
              const chord = [];
              while (chord.length < chordSize) {
                const deg = scale[Math.floor(r() * scale.length)];
                const oct = Math.floor(r() * (goal === "focus" ? 2 : 3)) * 12;
                const semi = deg + oct;
                if (!chord.includes(semi)) chord.push(semi);
              }
              chord.sort((a, b) => a - b);

              const cfg = {
                goal,
                root,
                chord,
                wet: goal === "focus" ? between(0.12, 0.22) : goal === "calm" ? between(0.34, 0.55) : between(0.22, 0.38),
                lp: goal === "focus" ? between(1800, 6200) : goal === "calm" ? between(520, 2400) : between(900, 4200),
                drift: goal === "focus" ? between(0.002, 0.015) : goal === "calm" ? between(0.006, 0.060) : between(0.004, 0.038),
                tickDensity: goal === "focus" ? between(0.55, 0.95) : goal === "calm" ? between(0.0, 0.15) : between(0.18, 0.55),
                sparkle: goal === "calm" ? between(0.10, 0.28) : goal === "focus" ? between(0.22, 0.55) : between(0.35, 0.75)
              };
              cfg.label = `⟦ mode:${cfg.goal} root:${cfg.root} chord:[${cfg.chord.join(",")}] lp:${Math.round(cfg.lp)}Hz wet:${cfg.wet.toFixed(2)} drift:${cfg.drift.toFixed(3)} ticks:${cfg.tickDensity.toFixed(2)} sparkle:${cfg.sparkle.toFixed(2)} ⟧`;
              return cfg;
            }

            buildScene(goal, cfg, hard) {
              const ctx = this.ctx;
              const now = ctx.currentTime;
              const out = {};
              const sceneGain = ctx.createGain();
              sceneGain.gain.value = 1.0;
              sceneGain.connect(this.bus.input);
              out.sceneGain = sceneGain;

              const pad = this.makePad(goal, cfg, sceneGain);
              const air = this.makeAir(goal, cfg, sceneGain);
              out.pad = pad;
              out.air = air;

              out.tick = (t, strength) => this.playTick(goal, cfg, t, sceneGain, strength);
              out.sparkle = (t, strength) => this.playSparkle(goal, cfg, t, sceneGain, strength);
              out.update = (now, params) => this.applySceneMod(goal, cfg, out, now, params);
              out.dispose = () => {
                const safeStop = (n) => { try { n.stop(); } catch (_) { } try { n.disconnect(); } catch (_) { } };
                for (const v of pad.voices) { safeStop(v.osc); safeStop(v.lfo); try { v.gain.disconnect(); } catch (_) { } try { v.filt.disconnect(); } catch (_) { } }
                safeStop(air.src); try { air.gain.disconnect(); } catch (_) { } try { air.filt.disconnect(); } catch (_) { }
                try { sceneGain.disconnect(); } catch (_) { }
              };

              const fade = hard ? 0.20 : 0.65;
              sceneGain.gain.setValueAtTime(0.0001, now);
              sceneGain.gain.exponentialRampToValueAtTime(1.0, now + fade);
              return out;
            }

            makePad(goal, cfg, dest) {
              const ctx = this.ctx;
              const voices = [];
              const voiceCount = goal === "focus" ? 3 : goal === "calm" ? 4 : 5;
              const chosen = cfg.chord.slice(0, voiceCount);

              for (let i = 0; i < chosen.length; i++) {
                const semi = chosen[i];
                const osc = ctx.createOscillator();
                osc.type = goal === "focus" ? "triangle" : goal === "calm" ? "sine" : (i % 2 ? "triangle" : "sine");
                const gain = ctx.createGain();
                gain.gain.value = 0.0;
                const filt = ctx.createBiquadFilter();
                filt.type = "lowpass";
                filt.Q.value = 0.25;

                const lfo = ctx.createOscillator();
                lfo.type = "sine";
                lfo.frequency.value = lerp(0.006, 0.08, cfg.drift) * (0.8 + Math.random() * 0.6);
                const lfoGain = ctx.createGain();
                lfoGain.gain.value = goal === "focus" ? 8 : goal === "calm" ? 22 : 16;

                const baseMidi = cfg.root - 12 + semi;
                osc.frequency.value = midiToHz(baseMidi);
                osc.detune.value = (Math.random() * 2 - 1) * (goal === "focus" ? 6 : goal === "calm" ? 18 : 12);

                lfo.connect(lfoGain);
                lfoGain.connect(osc.detune);

                osc.connect(filt);
                filt.connect(gain);
                gain.connect(dest);

                const t = ctx.currentTime;
                const target = goal === "focus" ? 0.06 : goal === "calm" ? 0.10 : 0.11;
                gain.gain.setValueAtTime(0.0, t);
                gain.gain.linearRampToValueAtTime(target / voiceCount, t + 2.2 + i * 0.28);

                osc.start();
                lfo.start();
                voices.push({ osc, gain, filt, lfo, lfoGain });
              }

              return { voices };
            }

            makeAir(goal, cfg, dest) {
              const ctx = this.ctx;
              const src = ctx.createBufferSource();
              src.buffer = this.noise;
              src.loop = true;

              const filt = ctx.createBiquadFilter();
              filt.type = goal === "focus" ? "bandpass" : "highpass";
              filt.Q.value = goal === "focus" ? 1.0 : 0.62;
              filt.frequency.value = goal === "calm" ? 160 : goal === "focus" ? 1400 : 520;

              const gain = ctx.createGain();
              gain.gain.value = goal === "calm" ? 0.012 : goal === "focus" ? 0.006 : 0.010;

              src.connect(filt);
              filt.connect(gain);
              gain.connect(dest);
              src.start();

              return { src, gain, filt };
            }

            playTick(goal, cfg, t, dest, strength) {
              if (goal === "calm" && cfg.tickDensity < 0.06) return;
              const ctx = this.ctx;
              const src = ctx.createBufferSource();
              src.buffer = this.noise;
              src.loop = false;

              const filt = ctx.createBiquadFilter();
              filt.type = "bandpass";
              filt.Q.value = goal === "focus" ? 12 : 8;
              filt.frequency.value = goal === "focus" ? lerp(1100, 2400, Math.random()) : lerp(520, 1800, Math.random());

              const gain = ctx.createGain();
              const a = (goal === "focus" ? 0.020 : 0.012) * strength;
              gain.gain.setValueAtTime(0.0001, t);
              gain.gain.exponentialRampToValueAtTime(a, t + 0.006);
              gain.gain.exponentialRampToValueAtTime(0.0001, t + (goal === "focus" ? 0.028 : 0.042));

              src.connect(filt);
              filt.connect(gain);
              gain.connect(dest);

              src.start(t);
              src.stop(t + 0.06);
            }

            playSparkle(goal, cfg, t, dest, strength) {
              const ctx = this.ctx;
              const carrier = ctx.createOscillator();
              const mod = ctx.createOscillator();
              carrier.type = "sine";
              mod.type = "sine";

              const modGain = ctx.createGain();
              modGain.gain.value = goal === "focus" ? 220 : goal === "calm" ? 120 : 180;

              const filt = ctx.createBiquadFilter();
              filt.type = "bandpass";
              filt.Q.value = goal === "calm" ? 3.2 : 6.0;
              filt.frequency.value = goal === "calm" ? lerp(520, 1800, Math.random()) : lerp(900, 3600, Math.random());

              const gain = ctx.createGain();
              const amp = (goal === "focus" ? 0.012 : goal === "calm" ? 0.010 : 0.014) * strength;
              gain.gain.setValueAtTime(0.0001, t);
              gain.gain.exponentialRampToValueAtTime(amp, t + 0.012);
              gain.gain.exponentialRampToValueAtTime(0.0001, t + lerp(0.10, 0.22, Math.random()) * (goal === "focus" ? 0.8 : 1.2));

              const root = cfg.root + cfg.chord[Math.floor(Math.random() * cfg.chord.length)];
              const midi = root + (Math.random() < 0.5 ? 12 : 0) + (goal === "calm" && Math.random() < 0.35 ? 12 : 0);
              const hz = midiToHz(midi);

              carrier.frequency.setValueAtTime(hz, t);
              mod.frequency.setValueAtTime(hz * (goal === "focus" ? 1.5 : 1.0), t);

              mod.connect(modGain);
              modGain.connect(carrier.frequency);

              carrier.connect(filt);
              filt.connect(gain);
              gain.connect(dest);

              carrier.start(t);
              mod.start(t);
              carrier.stop(t + 0.35);
              mod.stop(t + 0.35);
            }

            applySceneMod(goal, cfg, scene, now, params) {
              const i = params.intensity;
              const b = params.brightness;
              const d = params.density;
              const r = params.regen;
              const coupling = params.coupling;
              const breath = params.breath;
              const coh = params.coh;
              const tension = params.tension;

              const breathWave = (breath - 0.5) * 2;
              const breathSoft = 1 - Math.abs(breathWave);

              const baseMaster = 0.26 + 0.09 * i;
              const masterMod = 1 + (0.08 * coupling * breathWave) * lerp(0.7, 1.0, coh);
              this.master.gain.setTargetAtTime(clamp(baseMaster * masterMod, 0.02, 0.36), now, 0.14);

              const lp = clamp(cfg.lp * lerp(0.70, 1.25, b) * (1 + 0.12 * coupling * breathWave), 260, 9000);
              this.bus.filter.frequency.setTargetAtTime(lp, now, 0.14);

              const wet = clamp(cfg.wet + 0.10 * coh + 0.06 * breathSoft - 0.12 * tension, 0.08, 0.62);
              this.bus.wet.gain.setTargetAtTime(wet, now, 0.22);
              this.bus.dry.gain.setTargetAtTime(clamp(0.98 - wet * 0.55, 0.55, 1.0), now, 0.22);

              const padGain = lerp(0.55, 1.10, i) * lerp(0.75, 1.08, coh);
              const airGain = lerp(0.007, goal === "calm" ? 0.016 : 0.012, d) * lerp(0.8, 1.2, b);

              for (const v of scene.pad.voices) {
                const g = v.gain.gain;
                const current = g.value || 0.0001;
                const target = (0.10 + 0.26 * i) / scene.pad.voices.length * padGain;
                g.setTargetAtTime(target, now, 0.18);
                v.filt.frequency.setTargetAtTime(clamp(lp * lerp(0.55, 0.95, r), 220, 9000), now, 0.22);
                if (current < 0.00012) g.setValueAtTime(0.00012, now);
              }

              scene.air.gain.gain.setTargetAtTime(airGain, now, 0.18);
              scene.air.filt.frequency.setTargetAtTime(goal === "focus" ? clamp(lerp(900, 2600, b), 600, 4200) : clamp(lerp(120, 900, b), 80, 1600), now, 0.22);

              const driftHz = lerp(0.010, 0.085, cfg.drift) * lerp(0.9, 1.25, r);
              for (const v of scene.pad.voices) v.lfo.frequency.setTargetAtTime(driftHz * (0.7 + Math.random() * 0.8), now, 0.6);
            }

            boundarySilence() {
              const t = this.ctx.currentTime;
              this.master.gain.cancelScheduledValues(t);
              this.master.gain.setValueAtTime(this.master.gain.value, t);
              this.master.gain.linearRampToValueAtTime(0.05, t + 0.45);
              this.master.gain.linearRampToValueAtTime(0.28, t + 1.45);
              this.setGoal(ui.sessionGoal.value, false);
            }

            schedule() {
              if (!this.running || !this.ctx || !this.scene) return;
              const now = this.ctx.currentTime;
              const lookAhead = 0.16;

              const cycle = Math.max(1,
                parseInt(ui.inhaleSec.value || "0", 10) +
                parseInt(ui.hold1Sec.value || "0", 10) +
                parseInt(ui.exhaleSec.value || "0", 10) +
                parseInt(ui.hold2Sec.value || "0", 10)
              );

              const goal = state.config?.goal || "rebalance";
              const cfg = state.config;

              const bpm = goal === "focus" ? lerp(92, 118, clamp(state.brightness)) : lerp(68, 92, clamp(state.regen));
              const beat = 60 / bpm;
              const grid = goal === "focus" ? beat / 2 : beat;

              while (this.nextEventAt < now + lookAhead) {
                const coupling = parseFloat(ui.breathStrength.value);
                const intensity = clamp(state.intensity);
                const d = clamp(state.density);
                const r = clamp(state.regen);

                const tickChance = clamp(cfg.tickDensity * (0.20 + 0.80 * d) * (0.65 + 0.35 * (1 - r)), 0, 0.95);
                const sparkleChance = clamp(cfg.sparkle * (0.15 + 0.85 * intensity) * (0.55 + 0.45 * r), 0, 0.95);

                const microJitter = (goal === "focus" ? 0.008 : 0.016) * (Math.random() * 2 - 1);
                const t = this.nextEventAt + microJitter;

                const breathWeight = 0.55 + 0.45 * state.breath.smoothAmp;
                const strength = (0.40 + 0.60 * intensity) * lerp(0.75, 1.15, coupling) * breathWeight;

                if (Math.random() < tickChance) this.scene.tick(t, strength);
                if (Math.random() < sparkleChance * 0.55) this.scene.sparkle(t, strength * 0.85);

                this.nextEventAt += grid;
              }
            }
          }

          const audio = new AudioEngine();

          const buf = new Uint8Array(1024);

          function updateMemory() {
            if (!audio.analyser) return;
            audio.analyser.getByteTimeDomainData(buf);
            let sum = 0;
            for (let i = 0; i < buf.length; i++) {
              const x = (buf[i] - 128) / 128;
              sum += x * x;
            }
            const rms = Math.sqrt(sum / buf.length);
            const energy = clamp(rms * 2.35);
            state.memory.energyEMA = lerp(state.memory.energyEMA, energy, 0.04);
          }

          function updateAura() {
            const breath = state.breath.smoothAmp;
            const bright = clamp(state.brightness);
            const dens = clamp(state.density);
            const tension = clamp(0.62 * state.memory.energyEMA + 0.20 * bright + 0.26 * dens);
            state.memory.tensionEMA = lerp(state.memory.tensionEMA, tension, 0.05);
            const centered = 1 - Math.abs(breath - 0.5) * 2;
            const calm = 1 - clamp(state.memory.tensionEMA);
            const coherence = clamp(0.55 * centered + 0.45 * calm);
            state.aura.coherenceEMA = lerp(state.aura.coherenceEMA, coherence, 0.06);
            state.aura.drift = (state.aura.drift + 0.012) % (Math.PI * 2);
            ui.aura.textContent = `▢ ${state.aura.coherenceEMA.toFixed(3)} (⟲ calm:${calm.toFixed(2)} breath:${centered.toFixed(2)})`;
            ui.mem.textContent = `energy:${state.memory.energyEMA.toFixed(3)} tension:${state.memory.tensionEMA.toFixed(3)}`;
          }

          function buildSession(goal, minutes) {
            const total = Math.max(2, Math.min(90, minutes | 0)) * 60;
            const templates = {
              rebalance: [
                { dur: 60, tag: "⦿ ⟶ △", ax: "Ax 2.1", txt: "Notice fragments. Do not fix them. Let breath be the only vector." },
                { dur: 120, tag: "△ ⟲", ax: "Ax 24.2", txt: "Each exhale is ⌀. Each inhale is ⟲. Let the pause reorganize." },
                { dur: 180, tag: "▢", ax: "Ax 2.3", txt: "Sense connection: body ↔ mind ↔ space. Reduce force; increase clarity." },
                { dur: 120, tag: "⟦…⟧", ax: "Ax 8.1", txt: "Feel options. Choose one tiny adjustment: jaw, tongue, shoulders." },
                { dur: 120, tag: "⌀", ax: "Ax 15.1", txt: "Introduce a deliberate limit: soften sound, soften attention, keep breathing." }
              ],
              focus: [
                { dur: 60, tag: "△ ⟶ ■", ax: "Ax 4.2", txt: "Let one thread become structure: a single point in the breath." },
                { dur: 150, tag: "⟲", ax: "Ax 10.2", txt: "Return whenever mind drifts. No conflict. Only return." },
                { dur: 150, tag: "▢", ax: "Ax 2.3", txt: "Hold connection: breath + sound + posture. Keep it simple." },
                { dur: 120, tag: "⌀", ax: "Ax 3.3", txt: "If language appears, let it reach ⌀ and dissolve. Continue the cycle." }
              ],
              calm: [
                { dur: 60, tag: "⌀", ax: "Ax 15.1", txt: "Begin with boundary: slow down. Lower brightness. Let silence lead." },
                { dur: 180, tag: "⌀ ⟲", ax: "Ax 24.2", txt: "Pause is recursive. Exhale longer if needed. Reduce density gently." },
                { dur: 120, tag: "⦿", ax: "Ax 1.1", txt: "Allow totality to be present without analysis. Stay with the field." },
                { dur: 120, tag: "▢", ax: "Ax 20.1", txt: "Let body organize mind. Align breathing and soften the gaze." }
              ]
            };
            const base = templates[goal] || templates.rebalance;
            const steps = [];
            let t = 0;
            let i = 0;
            while (t < total) {
              const s = base[i % base.length];
              const remaining = total - t;
              const dur = Math.min(s.dur, remaining);
              steps.push({ ...s, dur });
              t += dur;
              i++;
            }
            steps.unshift({ dur: 30, tag: "⟦…⟧ ⟶", ax: "Ax 8.1", txt: "Set intention inside limits. Start where you are." });
            steps.push({ dur: 30, tag: "⌀", ax: "Ax 24.2", txt: "Close with ⌀. Keep the after-effect. Do not rush to interpret." });
            return steps;
          }

          function applySessionStep(step) {
            const goal = ui.sessionGoal.value;
            const n = (v, target, amt) => lerp(v, target, amt);
            if (goal === "rebalance") {
              state.brightness = n(state.brightness, 0.30, 0.18);
              state.density = n(state.density, 0.36, 0.18);
              state.regen = n(state.regen, 0.68, 0.12);
              state.silenceBias = n(state.silenceBias, 0.22, 0.14);
            } else if (goal === "focus") {
              state.brightness = n(state.brightness, 0.42, 0.14);
              state.density = n(state.density, 0.28, 0.12);
              state.regen = n(state.regen, 0.56, 0.10);
              state.silenceBias = n(state.silenceBias, 0.14, 0.10);
            } else {
              state.brightness = n(state.brightness, 0.20, 0.18);
              state.density = n(state.density, 0.22, 0.16);
              state.regen = n(state.regen, 0.76, 0.14);
              state.silenceBias = n(state.silenceBias, 0.30, 0.16);
            }
            if (!state.frozen) {
              ui.brightness.value = clamp(state.brightness);
              ui.density.value = clamp(state.density);
              ui.regen.value = clamp(state.regen);
              ui.silenceBias.value = clamp(state.silenceBias);
              syncValues();
            }
            ui.intent.textContent = `${step.tag} ⟶ ${step.ax}`;
            ui.prompt.innerHTML = `<b>${step.tag}</b> — ${step.txt} <span class="mono">${step.ax}</span>`;
          }

          function startSession(now) {
            const goal = ui.sessionGoal.value;
            const minutes = parseInt(ui.sessionMin.value || "10", 10);
            const steps = buildSession(goal, minutes);
            let cursor = now;
            for (const s of steps) { s._startAt = cursor; s._endAt = cursor + s.dur; cursor = s._endAt; }
            state.session.active = true;
            state.session.startAt = now;
            state.session.endAt = steps[steps.length - 1]._endAt;
            state.session.stepIdx = 0;
            state.session.steps = steps;
            applySessionStep(steps[0]);
          }

          function updateSession(now) {
            if (ui.sessionMode.value !== "guided") return;
            if (!state.session.active) return;
            if (now >= state.session.endAt) { state.session.active = false; ui.intent.textContent = "⌀ ⟶ Ax 24.2"; ui.prompt.innerHTML = `<b>⌀</b> — keep the quiet trace (⟲). <span class="mono">Ax 24.2</span>`; return; }
            const step = state.session.steps[state.session.stepIdx];
            if (!step) return;
            if (now >= step._endAt) {
              state.session.stepIdx = Math.min(state.session.stepIdx + 1, state.session.steps.length - 1);
              const next = state.session.steps[state.session.stepIdx];
              next._startAt = now;
              next._endAt = now + next.dur;
              applySessionStep(next);
              const boundaryP = clamp(0.015 + state.silenceBias * 0.10 + (state.memory.tensionEMA > 0.70 ? 0.06 : 0), 0, 0.26);
              if (Math.random() < boundaryP && (now - state.lastSilenceAt) > 14) { state.lastSilenceAt = now; audio.boundarySilence(); setStatus("⌀ (reconfigure)", "boundary"); }
            }
          }

          const c = ui.canvas;
          const g = c.getContext("2d");

          function drawField() {
            const w = c.width, h = c.height;
            g.clearRect(0, 0, w, h);

            g.save();
            g.globalAlpha = 0.10;
            g.strokeStyle = INK;
            g.lineWidth = 1;
            for (let i = 1; i < 6; i++) { const y = (h * i) / 6; g.beginPath(); g.moveTo(0, y); g.lineTo(w, y); g.stroke(); }
            for (let i = 1; i < 10; i++) { const x = (w * i) / 10; g.beginPath(); g.moveTo(x, 0); g.lineTo(x, h); g.stroke(); }
            g.restore();

            const breath = state.breath.smoothAmp;
            const coh = state.aura.coherenceEMA;
            const cx = w * 0.5, cy = h * 0.50;
            const baseR = Math.min(w, h) * 0.16;
            const r = baseR * (0.75 + 0.65 * breath);
            const rings = 5 + Math.round(7 * state.density);
            const spacing = lerp(18, 10, coh);

            g.save();
            g.strokeStyle = INK;
            for (let i = 1; i <= rings; i++) {
              const rr = r + i * spacing + 6 * Math.sin(state.aura.drift + i * 0.6);
              g.globalAlpha = lerp(0.05, 0.16, coh) * (1 - i / (rings + 1));
              g.lineWidth = lerp(1.2, 2.4, coh) * (1 - i / (rings + 2));
              g.beginPath();
              g.arc(cx, cy, rr, 0, Math.PI * 2);
              g.stroke();
            }
            g.restore();

            g.save();
            g.fillStyle = INK;
            g.globalAlpha = 0.08 + 0.12 * coh;
            g.beginPath();
            g.arc(cx, cy, r, 0, Math.PI * 2);
            g.fill();
            g.globalAlpha = 0.50;
            g.lineWidth = 2;
            g.strokeStyle = INK;
            g.beginPath();
            g.arc(cx, cy, r, 0, Math.PI * 2);
            g.stroke();
            g.restore();

            if (audio.analyser && audio.running) {
              audio.analyser.getByteTimeDomainData(buf);
              g.save();
              g.strokeStyle = INK;
              g.globalAlpha = 0.45;
              g.lineWidth = 2;
              const ribbonY = h * 0.84;
              const amp = lerp(24, 64, clamp(state.memory.energyEMA));
              g.beginPath();
              for (let i = 0; i < buf.length; i++) {
                const x = (i / (buf.length - 1)) * w;
                const v = (buf[i] / 255);
                const y = ribbonY - (v - 0.5) * 2 * amp;
                if (i === 0) g.moveTo(x, y);
                else g.lineTo(x, y);
              }
              g.stroke();
              g.restore();
            }

            g.save();
            g.fillStyle = INK;
            g.globalAlpha = 0.75;
            g.font = "16px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
            g.fillText(`${ui.phase.textContent || ""}`, 18, 28);
            g.globalAlpha = 0.55;
            g.fillText(`▢ coherence:${state.aura.coherenceEMA.toFixed(3)}  ⟲ breath:${state.breath.smoothAmp.toFixed(3)}`, 18, 52);
            g.restore();

            requestAnimationFrame(drawField);
          }

          function tick() {
            if (!audio.running || !audio.ctx) return;

            if (!state.frozen) {
              state.intensity = parseFloat(ui.intensity.value);
              state.brightness = parseFloat(ui.brightness.value);
              state.density = parseFloat(ui.density.value);
              state.regen = parseFloat(ui.regen.value);
              state.silenceBias = parseFloat(ui.silenceBias.value);
            }

            const now = audio.ctx.currentTime;
            if (state.meditationEndAt && now >= state.meditationEndAt) { stopRun("time"); return; }

            stepBreath(now);
            updateMemory();
            updateAura();

            const params = {
              intensity: clamp(state.intensity),
              brightness: clamp(state.brightness),
              density: clamp(state.density),
              regen: clamp(state.regen),
              coupling: parseFloat(ui.breathStrength.value),
              breath: clamp(state.breath.smoothAmp),
              coh: clamp(state.aura.coherenceEMA),
              tension: clamp(state.memory.tensionEMA)
            };

            audio.scene?.update?.(now, params);

            if (ui.sessionMode.value === "free") {
              const boundaryP = clamp(0.008 + state.silenceBias * 0.07, 0, 0.18);
              if (Math.random() < boundaryP && (now - state.lastSilenceAt) > 18) { state.lastSilenceAt = now; audio.boundarySilence(); setStatus("⌀ (reconfigure)", "boundary"); }
            }

            updateSession(now);

            const remaining = state.meditationEndAt ? (state.meditationEndAt - now) : 0;
            updateGlyphStrip(true, remaining);
            if (ui.status.dataset.kind !== "boundary") setStatus("⦿ (field)", "field");
          }

          let tickTimer = null;

          function stopRun(reason = "stop") {
            if (!audio.running) return;
            document.body.classList.remove("is-running");
            state.session.active = false;
            state.meditationEndAt = 0;
            if (tickTimer) { clearInterval(tickTimer); tickTimer = null; }
            audio.stop(reason);
            setStatus(`⌀ (${reason})`, "idle");
            ui.phase.textContent = "silence";
            ui.intent.textContent = "⌀";
            ui.prompt.innerHTML = `<b>⌀</b> — ${reason === "time" ? "time is complete" : "stop"}. Keep what remains without forcing meaning.`;
            updateGlyphStrip(false, 0);
          }

          function isFullscreen() { return !!document.fullscreenElement; }
          async function enterFullscreen() { const target = document.documentElement; const req = target.requestFullscreen || target.webkitRequestFullscreen; if (req) await req.call(target); }
          async function exitFullscreen() { const exit = document.exitFullscreen || document.webkitExitFullscreen; if (exit) await exit.call(document); }
          async function toggleFullscreen() { try { if (isFullscreen()) await exitFullscreen(); else await enterFullscreen(); } catch (_) { } refreshFullscreenUI(); }
          function refreshFullscreenUI() { ui.fullscreen.textContent = isFullscreen() ? "Exit fullscreen" : "Fullscreen"; }

          document.addEventListener("fullscreenchange", refreshFullscreenUI);
          document.addEventListener("webkitfullscreenchange", refreshFullscreenUI);
          ui.fullscreen.addEventListener("click", toggleFullscreen);

          document.addEventListener("keydown", (e) => {
            if (e.repeat) return;
            const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
            if (tag === "input" || tag === "select" || tag === "textarea") return;
            if (e.key === "f" || e.key === "F") toggleFullscreen();
            if (e.key === "Escape" && isFullscreen()) exitFullscreen();
          });

          ui.newConfig.addEventListener("click", () => {
            if (!audio.ctx) return;
            audio.setGoal(ui.sessionGoal.value, false);
            setStatus("■ (new ⟦…⟧)");
            ui.prompt.innerHTML = `<b>⟦…⟧</b> — reconfigure gently. Keep breath continuous (⟶).`;
          });

          ui.freeze.addEventListener("click", () => {
            state.frozen = !state.frozen;
            ui.freeze.textContent = state.frozen ? "Unfreeze (⫶)" : "Freeze (⫶)";
            setStatus(state.frozen ? "⫶ (suspended)" : "⦿ (field)");
            ui.prompt.innerHTML = state.frozen ? `<b>⫶</b> — suspend adjustments. Keep breath as the only vector (⟶).` : `<b>⦿</b> — resume evolution with limits (⌀).`;
          });

          ui.sessionGoal.addEventListener("change", () => {
            if (!audio.running) return;
            audio.setGoal(ui.sessionGoal.value, true);
            setStatus(`■ (mode:${ui.sessionGoal.value})`);
          });

          ui.start.addEventListener("click", async () => {
            if (audio.running) return;
            await audio.start();
            document.body.classList.add("is-running");
            setStatus("⦿ (field)", "field");
            const minutes = Math.max(2, Math.min(90, parseInt(ui.sessionMin.value || "10", 10)));
            state.meditationEndAt = audio.ctx.currentTime + minutes * 60;

            state.breath.phase = "silence";
            state.breath.tPhaseStart = audio.ctx.currentTime;
            state.breath.phaseDur = 0.1;
            state.breath.amp = 0.0;
            state.breath.smoothAmp = 0.0;
            ui.phase.textContent = "inhale ⟶";

            const now = audio.ctx.currentTime;
            if (ui.sessionMode.value === "guided") startSession(now);
            else { ui.intent.textContent = "free ⟶ ▢ ⟲"; ui.prompt.innerHTML = `<b>▢</b> — free mode. Let breath coordinate sound. Introduce ⌀ only if needed.`; }

            if (!tickTimer) tickTimer = setInterval(tick, 100);
            drawField();
            refreshFullscreenUI();
          });

          ui.stop.addEventListener("click", () => stopRun("stop"));

          refreshFullscreenUI();
          updateGlyphStrip(false, 0);
        })();
      </script>
    </section>
  </div>
</body>
</html>
